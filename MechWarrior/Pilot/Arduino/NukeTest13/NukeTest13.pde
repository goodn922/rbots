/*
 * Auto-Generated by NUKE!
 *   http://arbotix.googlecode.com
 */

#include <ax12.h>
#include <BioloidController.h>
#include <Commander.h>
#include "nuke.h"
#include <Wire.h>
//#include "TimerThree.h"
#include <Servo.h> 

#define ADDRESS 0x60      // Defines address of CMPS10

Commander command = Commander();

byte hitPoint = 0x05;

// hitReport is a status counter to report hits
int hitReport;
// hitEvent is a status counter to time hits
int hitEvent;

//Volatile: Specifically, it directs the compiler to load the variable from RAM 
//and not from a storage register, which is a temporary memory 
//location where program variables are stored and manipulated. 
//Under certain conditions, the value for a variable stored in registers can be inaccurate.
// maybe a speed improvement also
// 1:
// 2:
// 3:
// 4:
byte hitPlate = 0x00;
int hitPlateInt = 0;
// number of times it has been hit
byte hitCount = 0x00;
// calculates the length of the interrupt pulse which corresponds to which target plate was hit
unsigned long hitTime;
  

byte tgtPlate = 0x03;
int gunPin = 40;

Servo ServoRIR;
Servo ServoLIR;
int   servoRPos =100;
int   servoLPos = 10;
int   servoRPin = 7;
int   servoLPin = 6;
int   dirServo = 1;
// target sensor input pin, used as interrupt 
// to read which target sensor was hit
int targetSensor = 0;
int startCmdTimeout = 0;
int dirTimeout = 1;
int TimoutFlag = 0;

unsigned long timeGunStart = 0;
unsigned long startTimoutTimer = 0;
    
void setup(){
    Wire.begin();
    pinMode(0,OUTPUT);
    pinMode(gunPin,OUTPUT);
    pinMode(13,OUTPUT);
    digitalWrite(13,LOW);
    digitalWrite(gunPin,LOW);
    hitReport = 0;
    hitEvent = 0;
    //attachInterrupt(targetSensor, interruptTargetHit, CHANGE);
    
    //Timer3.initialize(500000);  // 1/2 second period
    //Timer3.attachInterrupt(callback); 
    //Timer3.stop();
    // setup IK
    setupIK();
    gaitSelect(AMBLE); //RIPPLE
    // setup serial
    Serial.begin(38400);

    // wait, then check the voltage (LiPO safety)
    delay (1000);
    float voltage = (ax12GetRegister (1, AX_PRESENT_VOLTAGE, 1)) / 10.0;
    //Serial.print ("System Voltage: ");
    //Serial.print (voltage);
    //Serial.println (" volts.");
    //if (voltage < 10.0)
    //    while(1);

  
    // stand up slowly
    ax12SetRegister(13, 24, 1);  // rbots enable torque on az motor
    ax12SetRegister(14, 24, 1);  // rbots enable torque on el motor
    ax12SetRegister2(13, 8, 1023);  // max az CCW angle limit
    ax12SetRegister2(14, 6, 545);  // max el CW angle limit
    ax12SetRegister2(14, 8, 750);  // max el CCW angle limit
    ax12SetRegister2(13, 32, command.goalAzSpeed);  // set az speed
    ax12SetRegister2(14, 32, command.goalElSpeed);  // set el speed
    ax12SetRegister2(13, 30, command.goalAzPos);  // rbots az pos, should have default value at beginning of 511
    ax12SetRegister2(14, 30, command.goalElPos);  // rbots el pos, should have default value at beginning of 600
    
    bioloid.poseSize = 12;
    bioloid.readPose();
    doIK();
    bioloid.interpolateSetup(1000);
    while(bioloid.interpolating > 0){
        bioloid.interpolateStep();
        delay(3);
    }
    
    
    
    ServoRIR.attach(servoRPin);  // attaches the servo to pin
    ServoLIR.attach(servoLPin);  // attaches the servo to pin
    
    
}

void loop(){
  
//  if(TimoutFlag > 10)
//  {
//    TimoutFlag = 0;
//    command.walkV = 0;  
//  }
//  
//  if(TimoutFlag > 0)
//  {
//    TimoutFlag++; 
//  }
  ServoRIR.write(servoRPos);
  ServoLIR.write(servoLPos);
  
//    if( dirServo )
//    {
//      servoRPos+=5;
//      servoLPos+=5;
//    }
//    else
//    {
//      servoRPos-=5;
//      servoLPos-=5;
//    }
//    
//    if(servoRPos >= 110) {
//      dirServo = 0;
//    }
//    
//    if(servoLPos <= 10) {
//      dirServo = 1;
//    }
  
  // update IK if needed
  if(bioloid.interpolating == 0){
    doIK();
    bioloid.interpolateSetup(tranTime);
  }
  // update joints
  bioloid.interpolateStep();
  // take commands
  if(command.gunFire == 1 && !digitalRead(13))
  {
      digitalWrite(gunPin,HIGH);
      digitalWrite(13,HIGH);
      command.gunFire = 0;
      //Timer3.start();
      timeGunStart = millis();
      
  }
  startCmdTimeout = 1;
  // on first walk command start 15 second dead robot timer
  if(command.walkV > 0 || command.walkV < 0)
  {
    startCmdTimeout = 1;
    startTimoutTimer = millis(); 
  }
  
  if( startCmdTimeout && (millis() - startTimoutTimer > 9000 ))
    {
       TimoutFlag = 1;
      // bioloid.interpolating = 0;
       if(dirTimeout)
       {
         command.walkV = 100;
         dirTimeout = 0;
       }
       {
         //command.walkV = -100; 
         dirTimeout = 1;
       }
       //startTimoutTimer = millis();
    }
    
  if( (millis() - timeGunStart) > 500 )
  {
    digitalWrite(13, LOW);
    digitalWrite(gunPin,LOW);  
  }
    
  if(command.ReadMsgs() > 0){
    
    // reset 15 sec timer
    startTimoutTimer = millis();
    
    // move azimuth turret
     
    ax12SetRegister2(13, 32, command.goalAzSpeed);  // rbots el vel
    ax12SetRegister2(14, 32, command.goalElSpeed);  // rbots el vel
    ax12SetRegister2(13, 30, command.goalAzPos);  // rbots az pos
    ax12SetRegister2(14, 30, command.goalElPos);  // rbots el pos
    
    
    digitalWrite(0,HIGH-digitalRead(0));
    Xspeed = ((command.walkV));
    if((command.buttons&BUT_LT) > 0)
    {
      Yspeed = (command.walkH);
      Rspeed = 0;
    }
    else
    {
      Rspeed = -(command.walkH)/250.0;
      Yspeed = 0;
    }
    bodyRotY = (((float)command.lookV))/250.0;
    if((command.buttons&BUT_RT) > 0)
      bodyRotX = ((float)command.lookH)/250.0;
    else
      bodyRotZ = ((float)command.lookH)/250.0;
  }
  else
  {
    
  }
  
  
  byte hByte, lByte, fine;      // highByte and lowByte store high and low bytes of the bearing and fine stores decimal place of bearing
  char pitch, roll;             // Stores pitch and roll values of CMPS10, chars are used because they support signed value
  int bearing;                               // Stores full bearing
   
  Wire.beginTransmission(ADDRESS);           //starts communication with CMPS10
  byte by = 2;
  Wire.send(by);                              //Sends the register we wish to start reading from
  Wire.endTransmission();

  Wire.requestFrom(ADDRESS, 4);              // Request 4 bytes from CMPS10
  while(Wire.available() < 4);               // Wait for bytes to become available
  hByte = Wire.receive();           
  lByte = Wire.receive();            
  pitch = Wire.receive();              
  roll = Wire.receive();               
   
  bearing = ((hByte<<8)+lByte)/10;      // Calculate full bearing
  fine = ((hByte<<8)+lByte)%10;         // Calculate decimal place of bearing
  
  int frontIR = analogRead(0);
  int leftIR = analogRead(1);  
  int rightIR = analogRead(2); 
  int backIR = analogRead(3);
  int servoRightIR = analogRead(4);
  int servoLeftIR = analogRead(5);
  
  byte lowFrontIR  = (byte) frontIR;
  byte highFrontIR = (byte) (frontIR >> 8);

  byte lowLeftIR  = (byte) leftIR;
  byte highLeftIR = (byte) (leftIR >> 8);
  
  byte lowRightIR  = (byte) rightIR;
  byte highRightIR = (byte) (rightIR >> 8);
    
  byte lowBackIR  = (byte) backIR;
  byte highBackIR = (byte) (backIR >> 8);
  
  byte lowServoRightIR  = (byte) servoRightIR;
  byte highServoRightIR = (byte) (servoRightIR >> 8);
  
  byte lowServoLeftIR  = (byte) servoLeftIR;
  byte highServoLeftIR = (byte) (servoLeftIR >> 8);
  
  
  
  Serial.print("*");   // rbots
  Serial.print("*");   // rbots
  Serial.print(hitCount);   // rbots
  Serial.print(hitPlate);   // rbots
  Serial.print(hByte);   // rbots
  Serial.print(lByte);   // rbots
  Serial.print(pitch);   // rbots
  Serial.print(roll);   // rbots
  Serial.print(lowLeftIR);  // rbots
  Serial.print(highLeftIR); // rbots
  Serial.print(lowRightIR); // rbots
  Serial.print(highRightIR); // rbots
  Serial.print(lowFrontIR);  // rbots
  Serial.print(highFrontIR); // rbots
  Serial.print(lowBackIR); // rbots
  Serial.print(highBackIR); // rbots
  Serial.print(lowServoRightIR); // rbots
  Serial.print(highServoRightIR); // rbots
  Serial.print((byte) servoRPos); // rbots
  Serial.print(lowServoLeftIR); // rbots
  Serial.print(highServoLeftIR); // rbots
  Serial.print((byte) servoLPos); // rbots
  Serial.print((byte) command.checkS); // rbots
  
}

void interruptTargetHit()  {
  if(hitEvent < 1)  {  // line went high, this is a hit
    hitTime = millis();
    hitEvent = 1;  } 
  else  {
    hitCount++;
    hitTime = millis() - hitTime;
    hitPlateInt = hitTime/50;
    // let the main loop know to report a hit
    hitReport = 1;
    switch (hitPlateInt)
    {
      case 1:
        hitPlate = 0x01;
        break;
      case 2:
        hitPlate = 0x02;
        break;
      case 3:
        hitPlate = 0x03;
        break;
      case 4:
        hitPlate = 0x04;
        break;
      default:
        hitPlate = 0x00;
        hitReport = 0;
        break;
      
    }
    // reset to check for signal to go high
    hitEvent = 0;
    
    }
}

//void callback()
//{
//  digitalWrite(13, LOW);
//  digitalWrite(gunPin,LOW);
//  Timer3.stop();
//}  

